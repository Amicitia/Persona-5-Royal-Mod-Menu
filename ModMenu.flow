// Import the MessageScript into the script
// The compiler will insert constant variables for each of the 
// window identifiers.
import( "ModMenu.msg" );
import( "Math.flow" );
import( "Utilities.flow" );

// Store this for animating the last spawned npc
global int gLastSpawnedNpcModelHandle;
global int gFldAnimGapId;
global int gFldAnimGapIndex;
global float gFldAnimSpeed;
global bool gFldAnimShouldLoop;
global int gNpcAnimGapId;
global int gNpcAnimGapIndex;
global int gFldAnimTime;
global float gLastCamXRot;
global float gLastCamYRot;
global float gLastCamZRot;
global int gFieldMajor;
global int gFieldMinor;
global int gEventMajor;
global int gEventMinor;

void ModMenuDisplay()
{
	while ( true )
	{
		int selection = SEL_GENERIC( -1, ModMenu );
        
        PUTS( "ModMenuDisplay(): " );
        PUT( selection );
		
		switch ( selection )
		{
            case -1:
                return;
			case 0:
				PlayerEditorDisplay();
				break;
			case 1:
				BattleTypeSelect();
				return;
			case 2: 
				TeleportModeStart();
				break;
			case 3: 
				BgmSelect();
				break;
			case 4:
				FieldSelect();
				return;
			case 5:
				EventSelect();
				return;
			case 6:
				CameraEditorDisplay(); 
				break;
			case 7:
				NpcControlMenuDisplay(); 
				break;
			case 8: 
				FlagsEditorDisplay(); 
				break;
			case 9: 
				CalendarEditorDisplay(); 
				return;
			case 10: 
				CallOriginalSquareMenu();
				break;
			case 11:
				AboutDialogDisplay(); 
				break;
		}
	}
}


// Player Editor
void PlayerEditorDisplay()
{
	while ( true )
	{
		int selection = SEL_GENERIC( PlayerMenuName, PlayerMenu );
		switch ( selection )
		{
			case -1:
				return;
			case 0:
				PersonaEditorOpen();
				break;
			case 1:
				StatEditorDisplay();
				break;
			case 2: 
				ItemEditorDisplay();
				break;
			case 3:
				CommuSetRankSelect();
				break;
			case 4: // Set Protag Name
				CALL_NAME_ENTRY();
				break;
			case 5: // Set Team Name
				CALL_PHANTOM_NAME_ENTRY();
				break;
			case 6:
				PlayerAnimViewerDisplay();
				break;
			case 7:
				PlayerSelectModelScale();
				break;
			case 8: 
				PlayerSetMaxMoney();
				break;
		}
	}
}

// Persona Stock Editor
void PersonaEditorOpen() 
{
	while ( true )
	{
		int selection = SEL_GENERIC( PersonaMenuName, PersonaMenu );
		switch ( selection )
		{
			case -1:
				return;
			case 0:
				PersonaAddSelect();
				break;
			case 1:
				PersonaDeleteAllSelect();
				break;
			case 2:
				PersonaAddSkillSelect();
				break;
		}
	}
}

void PersonaAddSelect()
{
	int personaId = SelectNumberPrompt( PersonaAddPrompt, 3 );
    
    if ( personaId == -1 )
        return;
    
    ADD_PERSONA_STOCK( personaId );
    MSG_SYSTEM( PersonaAdded );
}

void PersonaDeleteAllSelect()
{
	bool deleteConfirm = SelectNoYesPrompt( PersonaDelPrompt );
	
	if ( deleteConfirm == 1 ) {
		CLEAR_PERSONA_STOCK();
		MSG_SYSTEM( PersonaDeleted );
	}
	
}

void PersonaAddSkillSelect()
{
	int unitId = SEL_GENERIC( UnitMenuName, UnitSelect );
    if ( unitId == -1 ) // Cancel
        return;
        
	int skillId = SelectNumberPrompt( SkillPrompt, 3 );
    if ( skillId == -1 ) // Cancel
        return;
        
	SKILL_ADD( unitId, skillId );
	FADEIN( 0, 10 );
	FADE_SYNC();
	FLD_REQ_FLASHBACK( 152, 51 );
	FLD_END_FLASHBACK();
}

// Stat Editor
void StatEditorDisplay()
{
	while ( true )
	{
		int selection = SEL_GENERIC( StatsMenuName, StatsMenu );
        
        if ( selection == -1 )
            return;
        
		int pointsToAdd = SelectNumberPrompt( StatPrompt, 2 );
        
        if ( pointsToAdd == -1 )
            continue;

		switch ( selection )
		{
			case -1:
				return;
			case 0: // Knowledge
				StatAddPointAndDisplay( pointsToAdd, 0, 0, 0, 0 );
				break;
			case 1: // Charm
				StatAddPointAndDisplay( 0, pointsToAdd, 0, 0, 0 );
				break;
			case 2: // Proficiency
				StatAddPointAndDisplay( 0, 0, pointsToAdd, 0, 0 );
				break;
			case 3: // Guts
				StatAddPointAndDisplay( 0, 0, 0, pointsToAdd, 0 );
				break;
			case 4: // Kindness
				StatAddPointAndDisplay( 0, 0, 0, 0, pointsToAdd );
				break;
		}
	}
}

void StatAddPointAndDisplay( int p1, int p2, int p3, int p4, int p5 )
{
	ADD_PC_ALL_PARAM( p1, p2, p3, p4, p5 );
	DISP_PC_PARAM_METER();
}

// Item Editor
void ItemEditorDisplay() 
{
	while ( true )
	{
		int itemType = SEL_GENERIC( ItemMenuName, ItemMenu );
	
		switch ( itemType ) 
		{
			case -1:
				return;
			case 0: // Consumables
				ItemGetSelect( 12288 );
				break;
			case 1: // Accessories
				ItemGetSelect( 0x2000 );
				break;
			case 2: // Key Items
				ItemGetSelect( 0x4000 );
				break;
			case 3: // Ranged Weapon
				ItemGetSelect( 0x8000 );
				break;
			case 4: // Melee Weapons
				MSG_SYSTEM(MeleeError);
				break;
			case 5: // Outfits
				ItemGetSelect( 0x7000 );
				break;
			case 6: // Armor
				ItemGetSelect( 0x1000 );
				break;
			case 7: // Materials
				ItemGetSelect( 0x5000 );
				break;
			case 8: // Skill Cards
				ItemGetSelect( 24576 );
				break;
		}
	}
}

void ItemGetSelect( int type ) 
{
	int itemId = SelectNumberPrompt( ItemPrompt, 4 );
    if (itemId == -1)
        return;
	int amount = SelectNumberPrompt( ItemPrompt2, 2 );
    if (amount == -1)
        return;
	
	GET_ITEM_BUF_RESET();
	GET_ITEM_BUF_SET( type + itemId, amount );
	SET_ITEM_NUM( type + itemId, GET_ITEM_NUM( type + itemId ) + amount );
	GET_ITEMS_WINDOW( 0 );
}

void CommuSetRankSelect()
{
	int cmmId = SEL_GENERIC( CommuMenuName, CommuMenu );
	
	if ( cmmId < 22 && cmmId > 0 ) {
		DisplayMessagePrompt( CmmDialog2 );
		int lvl = SEL_GENERIC( -1, OneThruTen );
		
		if ( lvl <= 0 )
			return;
        
        if ( lvl > 0 ) {
            CMM_RANKUP( cmmId, lvl, 1 );
            
            if ( !CMM_EXIST( cmmId ) ) {
                CMM_OPEN( cmmId );
            }
            
            CMM_SET_LV( cmmId, lvl );
            CMM_ADD_POINT( cmmId, 9999);
        }
	}
}

void PlayerAnimViewerDisplay()
{
	while ( true )
	{
		int selection = SEL_GENERIC( AnimMenuName, AnimMenu );
	
		switch ( selection )
		{
			case -1:
				return;
			case 0: // Joker Animation Viewer
				FieldModelAnimViewerDisplay( FLD_PC_GET_RESHND( 0 ) );
				break;
			case 1: // Morgana Out of Bag
				SUB_MoruShowFace();
				break;
			case 2: // Morgana In Bag
				SUB_MoruReturnBag();
				break;
		}
	}
}

// Field Model Anim Viewer
void FieldModelAnimViewerDisplay(int resHandle) 
{
	while ( true )
	{
		int selection = SEL_GENERIC( GAPMenuName, GAPMenu );
		
		switch ( selection )
		{
			case -1:
				return;
			case 0:
				FieldModelAnimSelectId();
				break;
			case 1:
				FieldModelAnimSelectIndex();
				break;
			case 2:
				FieldModelAnimSelectLoop();
				break;
			case 3:
				FieldModelAnimSelectSpeed();
				break;
			case 4:
				FieldModelAnimSelectTime();
				break;
			case 5:
				FieldModelPlayAnim(resHandle, gFldAnimGapId, gFldAnimGapIndex);
				break;
		}	
	}
}

void FieldModelPlayAnim(int resHandle, int gapid, int index) 
{
	int clone = FLD_MODEL_CLONE_ADDMOTION( resHandle, gapid );
	FLD_UNIT_WAIT_DISABLE( clone );
	MDL_ANIM( clone, index, gFldAnimShouldLoop, 0, gFldAnimSpeed );
	WAIT(gFldAnimTime);
	FLD_MODEL_REVERT_ADDMOTION( resHandle, clone );
    //FLD_UNIT_SET_WAIT( resHandle );
}

void FieldModelAnimSelectId()
{
    int temp = SelectNumberPrompt( GapPrompt, 3 ); // Gap filename last 3 digits
    if ( temp != -1 )
        gFldAnimGapId = temp;
}

void FieldModelAnimSelectIndex()
{
    int temp = SelectNumberPrompt( GapPrompt2, 2 );
    if ( temp != -1 )
        gFldAnimGapIndex = temp;
}

void FieldModelAnimSelectLoop()
{
	gFldAnimShouldLoop = SelectOffOnPrompt( GapPrompt3 );
}

void FieldModelAnimSelectSpeed() 
{
    float temp = SelectFloatPrompt( GapPrompt5, 2 );
    if ( temp != -1 )
        gFldAnimSpeed = temp / 10;
}

void FieldModelAnimSelectTime() 
{
    int temp = SelectNumberPrompt( GapPrompt6, 1 );
    if ( temp != -1 )
        gFldAnimTime = temp * 30;
}

void PlayerSelectModelScale() 
{
    float temp = SelectFloatPrompt( ScalePrompt, 2 );
    if ( temp != -1 )
	{
        float modelScale = temp / 10;
        FLD_MODEL_SET_SCALE( FLD_PC_GET_RESHND( 0 ), modelScale );
    }
}

// Camera Editor
void CameraEditorDisplay()
{
	while ( true )
	{
		int selection = SEL_GENERIC( CameraMenuName, CameraMenu );
	
		switch ( selection )
		{
			case 0:
				return;
			case 1:
				CameraInputPos();
				break;
			case 2:
				CameraInputFov();
				break;
			case 3:
				CameraInputRot();
				break;
			case 4:
				CameraUnlock();
				break;
			case 5:
				CameraLock();
				break;
		}
	}
}

void CameraInputPos() 
{
	DisplayMessagePrompt( CameraPrompt );
	
	while ( !PAD_CHK_PRESS( PadButton.Triangle ) )
	{
		bool anyValueSet = false;
		
		if ( PAD_CHK_PRESS( PadButton.Any ) ) // if any button is pressed
		{
			float x = FLD_CAMERA_GET_X_POS();
			float y = FLD_CAMERA_GET_Y_POS();
			float z = FLD_CAMERA_GET_Z_POS();
			float multiplier = 1f;

			if ( PAD_CHK_PRESS( PadButton.Cross ) ) 
				multiplier = 3f;

			if ( PAD_CHK_PRESS( PadButton.Up ) ) 
			{
				y = y + ( 5f * multiplier );
				anyValueSet = true;
			}

			if ( PAD_CHK_PRESS( PadButton.Right ) ) 
			{
				x = x + ( 5f * multiplier );
				anyValueSet = true;
			}

			if ( PAD_CHK_PRESS( PadButton.Down ) ) 
			{
				y = y - ( 5f * multiplier );
				anyValueSet = true;
			}

			if ( PAD_CHK_PRESS( PadButton.Left ) ) 
			{
				x = x - ( 5f * multiplier );
				anyValueSet = true;
			}

			if ( anyValueSet ) 
				FLD_CAMERA_SET_POS( x, y, z );
		}
		
		WAIT( 3 );
	}
}

void CameraInputFov() 
{
	DisplayMessagePrompt( CameraPrompt );
	
	while ( !PAD_CHK_PRESS( PadButton.Triangle ) )
	{
		bool anyValueSet = false;
		
		if ( PAD_CHK_PRESS( PadButton.Any ) )
		{
			float fov = FLD_CAMERA_GET_FOVY();
			float multiplier = 1f;

			if ( PAD_CHK_PRESS( PadButton.Cross ) ) 
				multiplier = 5f;

			if ( PAD_CHK_PRESS( PadButton.Up ) ) 
			{
				fov = fov + ( 1f * multiplier );
				anyValueSet = true;
			}

			if ( PAD_CHK_PRESS( PadButton.Right ) ) 
			{
				fov = fov + ( 1f * multiplier );
				anyValueSet = true;
			}

			if ( PAD_CHK_PRESS( PadButton.Down ) ) 
			{
				fov = fov - ( 1f * multiplier );
				anyValueSet = true;
			}

			if ( PAD_CHK_PRESS( PadButton.Left ) ) 
			{
				fov = fov + ( 1f * multiplier );
				anyValueSet = true;
			}

			if ( anyValueSet ) 
				FLD_CAMERA_SET_FOVY(fov);
		}
		
		WAIT( 3 );
	}
}

void CameraInputRot() 
{
	const float ADD_VELOCITY_PER_PRESS = 15f;
    float cameraVelocityX = 0f;
    float cameraVelocityY = 0f;
    float cameraVelocityZ = 0f;  
	
	if ( ( gLastCamXRot == 0f ) && ( gLastCamYRot == 0f ) && ( gLastCamZRot == 0f ) ) 
	{
		gLastCamXRot = FLD_CAMERA_GET_X_ROT();
		gLastCamYRot = FLD_CAMERA_GET_Y_ROT();
		gLastCamZRot = FLD_CAMERA_GET_Z_ROT();
	}
	
    int runs = 0;

    while ( !PAD_CHK_PRESS( PadButton.Triangle ) )
    {
        if ( ++runs > 4 )
        {
            runs = 0;
            cameraVelocityX /= 2;
            cameraVelocityY /= 2;
            cameraVelocityZ /= 2;
        }
        
        if ( PAD_CHK_PRESS( PadButton.Any ) )
        {
            if ( PAD_CHK_PRESS( PadButton.Up ) ) 
            {
                if ( PAD_CHK_PRESS( PadButton.Square ) )
                    cameraVelocityZ += ADD_VELOCITY_PER_PRESS;
                else
                    cameraVelocityY += ADD_VELOCITY_PER_PRESS;
            }

            if ( PAD_CHK_PRESS( PadButton.Right ) ) 
                cameraVelocityX += ADD_VELOCITY_PER_PRESS;

            if ( PAD_CHK_PRESS( PadButton.Down ) ) 
            {
                if ( PAD_CHK_PRESS( PadButton.Square ) )
                    cameraVelocityZ -= ADD_VELOCITY_PER_PRESS;
                else
                    cameraVelocityY -= ADD_VELOCITY_PER_PRESS;
            }

            if ( PAD_CHK_PRESS( PadButton.Left ) ) 
                cameraVelocityX -= ADD_VELOCITY_PER_PRESS;
        }
		
        gLastCamXRot += cameraVelocityX;
		gLastCamYRot += cameraVelocityY;
		gLastCamZRot += cameraVelocityZ;
        CameraSetRot( gLastCamXRot, gLastCamYRot, gLastCamZRot );

        SYNC();
    }
}

void CameraSetRot( float x, float y, float z )
{
    float qX;
    float qY;
    float qZ;
    float qW;
    QuaternionFromEulerDegrees( x, y, z, out qX, out qY, out qZ, out qW );

    FLD_CAMERA_SET_ROT( qX, qY, qZ, qW );
}

void CameraUnlock()
{
	FLD_CAMERA_UNLOCK();
	FLD_CAMERA_BEHIND_UNLOCK();
}

void CameraLock()
{
	FLD_CAMERA_LOCK();
	FLD_CAMERA_BEHIND_LOCK();
}

// Npc Model Control
void NpcControlMenuDisplay()
{
	while ( true )
	{
		int selection = SEL_GENERIC( SpawnMenuName, SpawnMenu );
	
		switch ( selection )
		{
			case -1:
				return;
			case 0: // Spawn Model
				NpcSpawnSelect();
				break;
			case 1: // Animate Model
				NpcAnimViewerDisplay( gLastSpawnedNpcModelHandle );
				break;
		}
	}
}

void NpcSpawnSelect()
{
	int modelIdMajor = SelectNumberPrompt( NPCPrompt, 4 );
    if (modelIdMajor == -1)
        return;
	int modelIdMinor = SelectNumberPrompt( NPCPrompt2, 3 );
    if (modelIdMinor == -1)
        return;
	int modelIdSub = SelectNumberPrompt( NPCPrompt3, 2 );
    if (modelIdSub == -1)
        return;
	gLastSpawnedNpcModelHandle = NpcSpawn( modelIdMajor, modelIdMinor, modelIdSub );
}

int NpcSpawn( int modelIdMajor, int modelIdMinor, int modelIdSub )
{
	int pcHandle = FLD_PC_GET_RESHND( 0 );
	float x = FLD_MODEL_GET_X_TRANSLATE( pcHandle );
	float y = FLD_MODEL_GET_Y_TRANSLATE( pcHandle );
	float z = FLD_MODEL_GET_Z_TRANSLATE( pcHandle );
	float xr = FLD_MODEL_GET_X_ROTATE( pcHandle );
	float yr = FLD_MODEL_GET_Y_ROTATE( pcHandle );
	float zr = FLD_MODEL_GET_Z_ROTATE( pcHandle );
	
	int npcHandle = FLD_NPC_MODEL_LOAD( modelIdMajor, modelIdMinor, modelIdSub );
	FLD_MODEL_LOADSYNC( npcHandle );
	FLD_MODEL_SET_TRANSLATE( npcHandle, x, y, z, 0 );
	FLD_MODEL_SET_ROTATE( npcHandle, xr, yr, zr, 0 );
	FLD_MODEL_SET_VISIBLE( npcHandle, 1, 0 );
	
	return npcHandle;
}

void NpcAnimViewerDisplay( int resHandle ) 
{
	while ( true )
	{
		int selection = SEL_GENERIC( GAPMenuName, GAPMenu );
		
		switch ( selection )
		{ 
			case -1:
				return;
			case 0:
				NpcModelAnimSelectId();
				break;
			case 1:
				NpcModelAnimSelectIndex();
				break;
			case 2:
				FieldModelAnimSelectLoop();
				break;
			case 3:
				FieldModelAnimSelectSpeed();
				break;
			case 4:
				FieldModelAnimSelectTime();
				break;
			case 5:
				FieldModelPlayAnim(resHandle, gNpcAnimGapId, gNpcAnimGapIndex);
				break;
		}
	}
}

void NpcModelAnimSelectId()
{
    int temp = SelectNumberPrompt( GapPrompt, 3 );
    if ( temp != -1 )
        gNpcAnimGapId = temp;
}

void NpcModelAnimSelectIndex()
{
    int temp = SelectNumberPrompt( GapPrompt2, 2 );
    if ( temp != -1 )
        gNpcAnimGapIndex = temp;
}

// Battle
void BattleTypeSelect()
{
	int selection = SEL_GENERIC_NOT_HELP( BattleTypeName, BattleTypeMenu );
		
	switch ( selection )
	{
		case -1:
			return;
		case 0:
			RegularBattle();
			break;
		case 1:
			BossSelectMenu();
			break;
		case 2:
			EventBattle();
			break;
	}
}

void RegularBattle() 
{
	int encount = SelectNumberPrompt( EncounterPrompt, 3 );
    
    if ( encount == -1 )
        return;
	
	CALL_BATTLE(encount);
	WAIT_BATTLE();
}

void EventBattle()
{
	while ( true )
	{
		int selection = SEL_GENERIC( EventBattleName, EventBattleSelect );
		switch ( selection )
		{
			case -1:
				return;
			case 0:
				CALL_EVENTBATTLE( 422, 1, 779 );
				break;
			case 1:
				CALL_EVENTBATTLE( 422, 3, 781 );
				break;
			case 2: 
				CALL_EVENTBATTLE( 448, 1, 786 );
				break;
			case 3:
				CALL_EVENTBATTLE( 459, 2, 785 );
				break;
			case 4: 
				CALL_EVENTBATTLE( 500, 1, 790 );
				break;
			case 5:
				CALL_EVENTBATTLE( 131, 1, 647 );
				break;
		}
		CALL_FIELD(3,2,0,0);
	}
}

// Boss Select
void BossSelectMenu()
{
    // Select boss
    int bossId = SelectBoss();
    
    if ( bossId == -1 )
        return;
    
    // Start boss fight
    FLD_START_BOSS( bossId );
}


int SelectBoss()
{
    for ( int i = 0; i < 22; i++ )
	{
		// Print which index we're on
		PUTS( "SelectBoss: index:" );
		PUT( i );
        
		int selection = SEL_GENERIC( -1, i + SelectBoss );
        
        if (selection == -1)
            return -1;
		
		if ( selection == 5 ) // previous
		{
			// Continue increments i by 1, so to counter that
			// we subtract an additional 1 from i to go to the previous
			// iteration
			
			if ( i != 0 )
				i -= 2;
			else
				i = 20;
			
			continue;
		}
		else if ( selection == 6 ) // next
		{
			continue;
		}
		
		return selection + ( i * 4 ); 
	}
	
	return -1;
}

// Teleport Mode 
void TeleportModeStart()
{
    const float ADD_VELOCITY_PER_PRESS = 5f;
    
    int playerResHandle = FLD_PC_GET_RESHND( 0 );
    
    float playerVelocityX = 0f;
    float playerVelocityY = 0f;
    float playerVelocityZ = 0f;    
    int runs = 0;

    while ( !PAD_CHK_PRESS( PadButton.Triangle ) )
    {
        ++runs;
        if ( runs > 4 )
        {
            runs = 0;
            playerVelocityX /= 2;
            playerVelocityY /= 2;
            playerVelocityZ /= 2;
        }
        
        if ( PAD_CHK_PRESS( PadButton.Any ) )
        {
            if ( PAD_CHK_PRESS( PadButton.Up ) ) 
            {
                if ( PAD_CHK_PRESS( PadButton.Square ) )
                    playerVelocityZ += ADD_VELOCITY_PER_PRESS;
                else
                    playerVelocityY += ADD_VELOCITY_PER_PRESS;
            }

            if ( PAD_CHK_PRESS( PadButton.Right ) ) 
            {
                playerVelocityX += ADD_VELOCITY_PER_PRESS;
            }

            if ( PAD_CHK_PRESS( PadButton.Down ) ) 
            {
                if ( PAD_CHK_PRESS( PadButton.Square ) )
                    playerVelocityZ -= ADD_VELOCITY_PER_PRESS;
                else
                    playerVelocityY -= ADD_VELOCITY_PER_PRESS;
            }

            if ( PAD_CHK_PRESS( PadButton.Left ) ) 
            {
                playerVelocityX -= ADD_VELOCITY_PER_PRESS;
            }
        }
        
        float x = FLD_MODEL_GET_X_TRANSLATE( playerResHandle ) + playerVelocityX;
        float y = FLD_MODEL_GET_Y_TRANSLATE( playerResHandle ) + playerVelocityY;
        float z = FLD_MODEL_GET_Z_TRANSLATE( playerResHandle ) + playerVelocityZ;        
        FLD_MODEL_RUN_TRANSLATE( playerResHandle, x, y, z );

        SYNC();
    }
}

// BGM Select
void BgmSelect()
{
	// Display the dialog window
	MSG_WND_DSP(); 

	// Display dialog
	MSG( SelectBgmDialog, 0 ); 
	
	// Close the dialog window
	MSG_WND_CLS(); 

	int bgmId = SelectNumber( 3 );
    if ( bgmId == -1 )
        return;

	// Play bgm
	BGM( bgmId );
}

// Field Select
void FieldSelect()
{
	while ( true )
	{
		int selection = SEL_GENERIC( FieldMenuName, FieldMenu );
		
		switch ( selection )
		{ 
			case -1:
				return;
			case 0:
                int temp = SelectNumberPrompt( FieldDlg, 3 );
                if ( temp == -1 )
                    break;
				gFieldMajor = temp;
                
				temp = SelectNumberPrompt( FieldDlg2, 3 );
                if ( temp == -1 )
                    break;
                gFieldMinor = temp;
				break;
			case 1:
				if (gFieldMajor == 0 && gFieldMinor == 0)
					MSG_SYSTEM(LoadCheckError);
				else
					CALL_FIELD( gFieldMajor, gFieldMinor, 0, 0 );
				return;
		}
	}
	
}

// Event Select
void EventSelect() 
{
	while ( true )
	{
		int selection = SEL_GENERIC( EventMenuName, EventMenu );
		
		switch ( selection )
		{ 
			case -1:
				return;
			case 0:
                int temp = SelectNumberPrompt( EventDlg, 3 );
                if ( temp == -1 )
                    break;
				gEventMajor = temp;
                
				temp = SelectNumberPrompt( EventDlg2, 3 );
                if ( temp == -1 )
                    break;
                gEventMinor = temp;
				break;
			case 1:
				if ( gEventMajor == 0 && gEventMinor == 0 )
					MSG_SYSTEM(LoadCheckError);
				else
					CALL_EVENT( gEventMajor, gEventMinor);
				return;
		}
	}
}

void PlayerSetMaxMoney() 
{
	GET_MONEY_WINDOW( 999999, 0 );
    CALL_GLOBAL_MONEY_PANEL();
    CHANGE_GLOBAL_MONEY( 999999, 0 );
    DEL_GLOBAL_MONEY_PANEL();
}

// Calendar Editor
void CalendarEditorDisplay() 
{
	while ( true )
	{
		int selection = SEL_GENERIC( CalendarMenuName, CalendarMenu );
		
		switch (selection)
		{
			case -1:
				return;
			case 0:
				CalendarSetNextDaySelect();
				break;
			case 1:
				CallCalendar();
				return;
			case 2:
				ChangeWeather();
				break;
		}
	}
}

void CalendarSetNextDaySelect()
{
	int month = SEL_GENERIC_NOT_HELP( MonthMenuName, MonthMenu ) + 1;
    
    if ( month <= 0 )
        return;
        
    PUTS( "Month: " );
    PUT( month );
	
	int day = SelectNumberPrompt( CalendarPrompt2, 2 );
    
    PUTS( "Day: " );
    PUT( day );
	
	if ( day <= 0 )
	{
		// No matter how down you feel on some days, every day is still a positive one.
		MSG_SYSTEM( CalendarError );
		return;
	}
    
    int daysInMonth = 0;
    
    if ( month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12 ) daysInMonth = 31;
    else if ( month == 2 ) daysInMonth = 29;
    else if ( month == 4 || month == 6 || month == 9 || month == 11 ) daysInMonth = 30;
	
	// Verify that the day doesn't exceed the number of possible days in the specified month
	if ( day > daysInMonth )
	{
		MSG_SYSTEM( CalendarError );
		return;
	}
    
    int thisMonth = GET_MONTH();
    int thisDay = GET_DAY();
    
    PUTS( "Current Month: " );
    PUT( thisMonth );
    PUTS( "Current Day: " );
    PUT( thisDay );
    
    // We can only go backwards one day at a time, including jumping from the start of one month to the end of the previous month
    if ( ( ( month == thisMonth ) && ( ( day - thisDay ) < -1 ) ) ||
         ( ( month - thisMonth == -1 ) && ( thisDay == 1 && day != daysInMonth ) ) ||
         ( month - thisMonth < -1 )
       )
    {
        MSG_SYSTEM( CalendarBackwardsError );
		return;
    }
	
	SET_NEXT_DAY( month, day, 1 );
	PUT( month );
	PUT( day );
}

void CallCalendar()
{
	Fld_FadeOut_CallCalendar();
	CALL_CALENDAR();
}

void ChangeWeather() 
{
	int selection = SEL_GENERIC_NOT_HELP( WeatherMenuName, WeatherMenu );
		
	switch (selection)
	{
		case -1:
			break;
		default:
			PUSH_WEATHER( selection );
			break;
	}
}

// Flags Editor
void FlagsEditorDisplay() 
{
	// Flags start at 0x2D66 in the save file
	// section is 0x460 bytes long
	while ( true )
	{
		int selection = SEL_GENERIC( FlagMenuName, FlagMenu );
		
		switch (selection)
		{
			case -1:
				return;
			case 0:
				SelectHUDDisplayFlag();
				break;
			case 1:
				SelectAddPartyMember();
				break;
			case 2:
				SelectRemovePartyMember();
				break;
			case 3:
				EnablePartyEditing();
				break;
			case 4:
				SelectNavigator();
				break;
			case 5:
				SelectRomanceFlags();
				break;
			case 6:
				RoomEditorDisplay();
				break;
			case 7: // Manual Input
				SelectBitToggle();
				break;
			case 8:
				PrintEnabledBits();
				break;
		}
	}
}

void DisableAllBits() {
	for ( int i = 0; i < 3680; i++ ) {
		BIT_OFF( i );
	}
}

void PrintEnabledBits() {
	for ( int i = 0; i < 3680; i++ ) {
		if (BIT_CHK(i)) {
			PUT(i);
		}
	}
}

void SelectHUDDisplayFlag()
{
	int dateDisplay = SEL_GENERIC_NOT_HELP( -1, DateDisplayDlg );
	int hud = 0;
	
	switch (dateDisplay) {
        case -1:
            return;
		case 0:
			DATE_DISP( 1 );
			FLD_PANEL_DISP( 1 );
			hud = 1;
			break;
		case 1:
			DATE_DISP( 0 );
			FLD_PANEL_DISP( 0 );
			hud = 2;
			break;
	}

	MSG_WND_DSP(); 
	
	switch ( hud ) {
		case 0:
			break;
		case 1:
			MSG_SYSTEM( HudTest1); 
			break;
		case 2:
			MSG_SYSTEM( HudTest2); 
			break;
	}
	
	MSG_WND_CLS();
}

void SelectAddPartyMember()
{
	int unit = SEL_GENERIC_NOT_HELP( UnitMenuName, UnitSelect2 ) + 47;
	if ( unit == 46 ) // Cancel
        return;
		
	BIT_ON( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0100 + unit );
}

void SelectRemovePartyMember()
{
	int unit = SEL_GENERIC_NOT_HELP( UnitMenuName, UnitSelect2 ) + 47;
	if ( unit == 46 ) // Cancel
        return;
		
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0100 + unit );
}

void EnablePartyEditing()
{
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0103 + 0);
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0103 + 1);
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0103 + 2);
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0103 + 3);
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0103 + 4);
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0103 + 5);
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0103 + 6);
	BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 0x0103 + 7);
}

void SelectNavigator()
{
	int navi = SEL_GENERIC_NOT_HELP( NaviMenuName, NaviMenu );
	
	switch ( navi ) 
	{
		case -1:
			break;
		case 0: // Morgana
			BIT_ON( 0 + 0x0800 + 0x0800 + 0x1000 + 12 );
			BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 13 );
			break;
		case 1: // Futaba
			BIT_ON( 0 + 0x0800 + 0x0800 + 0x1000 + 13 );
			BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 12 );
			break;
		case 2: // None
			BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 12 );
			BIT_OFF( 0 + 0x0800 + 0x0800 + 0x1000 + 13 );
			break;
	}
}

void SelectRomanceFlags() {
	int lover = SEL_GENERIC_NOT_HELP( LoveMenuName, LoveMenu );
    if ( lover == -1 )
        return;
    
    lover += (0x0800 + 720);
	SelectItemToggle( lover );
}

void SelectBitToggle()
{
	int id = SelectNumber( 4 );
    if (id == -1)
        return;
    
	int onOff = SEL_GENERIC_NOT_HELP( -1, SelectOnOff );
	
	switch (onOff) 
	{
        case -1: // Back
            break;
		case 0: // On
			BIT_ON( id );
			break;
		case 1: // Off
			BIT_OFF( id );
			break;
	}
}

void SelectItemToggle(int flag) 
{
	int selection = SEL_GENERIC_NOT_HELP( -1, DateDisplayDlg );
	
	switch (selection) {
        case -1:
            break;
		case 0:
			BIT_ON( flag );
			break;
		case 1:
			BIT_OFF( flag );
			break;
	}
}

// Room Editor
void RoomEditorDisplay() 
{
	while ( true )
	{
		int roomSel = SEL_GENERIC_NOT_HELP( -1, RoomEdit );

		switch (roomSel) 
		{
			case -1:
				return;
			case 0:
				FurnitureEditorDisplay();
				break;
			case 1: 
				CollectibleEditorDisplay();
				break;
			case 2: 
				CleanlinessEditorDisplay();
				break;
		}
	}
}

// Furniture Editor
void FurnitureEditorDisplay() 
{
	while ( true )
	{
		int furnSel = SEL_GENERIC_NOT_HELP( -1, FurnEdit );
	
		switch ( furnSel ) 
		{
			case -1:
				return;
			case 0: // Plant
				SelectItemToggle(4230);
				break;
			case 1: // Sayuri
				SelectItemToggle(101);
				break;
			case 2: // DVD Player
				SelectItemToggle(3142);
				break;
			case 3: // Game Console
				SelectItemToggle(3146);
				break;
			case 4: // Old TV Set
				SelectItemToggle(4232);
				break;
			case 5: // Radio
				SelectItemToggle(4233);
				break;
			case 6: // Cat Bed
				SelectItemToggle(8121);
				break;
			case 7: // UFO Game Prizes
				int ufoPrize = SelectNumber(1);
				switch (ufoPrize) 
				{
					case 0: //
						SelectItemToggle(8186);
						break;
					case 1: //
						SelectItemToggle(8187);
						break;
					case 2: //
						SelectItemToggle(8188);
						break;
					case 3: //
						SelectItemToggle(8189);
						break;
					case 4: //
						SelectItemToggle(8190);
						break;
				}
				break;
		}
	}
}

// Collectible Editor
void CollectibleEditorDisplay() 
{
	while ( true )
	{
		int collSel = SEL_GENERIC_NOT_HELP( -1, CollEdit );
	
		switch ( collSel ) 
		{
			case -1:
				return;
			case 0: // Swan Boat
				SelectItemToggle(3456);
				break;
			case 1: // Ramen
				SelectItemToggle(3457);
				break;
			case 2: // Pennant
				SelectItemToggle(3458);
				break;
			case 3: // Statue
				SelectItemToggle(3459);
				break;
			case 4: // Sky Tree
				SelectItemToggle(3460);
				break;
			case 5: // Big Hera
				SelectItemToggle(3461);
				break;
			case 6: // Shumai
				SelectItemToggle(3462);
				break;
			case 7: // Fusen
				SelectItemToggle(3463);
				break;
			case 8: // I Love
				SelectItemToggle(3464);
				break;
			case 9: // Idol
				SelectItemToggle(3465);
				break;
			case 10: // Next
				CollectibleEditorDisplay2();
				break;
		}
	}
}

void CollectibleEditorDisplay2() 
{
    while ( true )
    {
		int collectables = SEL_GENERIC_NOT_HELP( -1, CollEdit2 );
                
		switch ( collectables ) 
        {
			case -1:
                return;
			case 0: // Seiza
                SelectItemToggle(3466);
                break;
			case 1: // Syogi
                SelectItemToggle(3467);
                break;
			case 2: // Hero
                SelectItemToggle(3468);
                break;
			case 3: // Hamaya
                SelectItemToggle(3469);
                break;
			case 4: // Jyainyan
                SelectItemToggle(3470);
                break;
			case 5: // Sushi
                SelectItemToggle(3471);
                break;
			case 6: // Choco
                SelectItemToggle(3472);
                break;
			case 7: // Kumade
                SelectItemToggle(3473);
                break;
            case 8: // Previous
                return;
        }
	}
}

// Cleanliness Editor
void CleanlinessEditorDisplay() 
{
	while ( true )
	{
		int cleanSel = SEL_GENERIC_NOT_HELP( -1, CleanEdit );
		switch (cleanSel) 
		{
			case -1:
				return;
			case 0: // Bookshelf
				SelectItemToggle(4229);
				break;
			case 1: // Work Bench
				SelectItemToggle(4231);
				break;
			case 2: // Visitors Table
				SelectItemToggle(8176);
				break;
			case 3: // Training Chair
				SelectItemToggle(3144);
				break;
			case 4: // Winter Heater
				SelectItemToggle(8147);
				break;
			case 5: // Laptop
				SelectItemToggle(3237);
				break;
		}
	}
}

// About Dialog
void AboutDialogDisplay() 
{
	DisplayMessagePrompt( AboutDlg );
}
